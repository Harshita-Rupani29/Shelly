# Single Commit Per Branch Policy

This document describes the single commit per branch policy for {{projectName}}.

## Policy Overview

Each feature branch must contain exactly **one commit** before merging to the release branch.

- [x] One commit per feature/fix branch
- [x] Semantic commit messages required
- [x] Squash commits before creating PR (or use GitHub squash merge)
- [x] Linear git history maintained
- [x] Easy to revert individual features

---

## Enforcement Mechanism

### Automated Validation

A GitHub Actions workflow validates the single commit policy on every pull request:

```yaml
name: Validate Single Commit

on:
  pull_request:
    branches: [release]

jobs:
  check-commits:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Count commits
        run: |
          # Use PR base/head SHAs for accurate commit counting
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          COMMIT_COUNT=$(git rev-list --count "$BASE_SHA..$HEAD_SHA")
          echo "Commits in PR: $COMMIT_COUNT"
          if [ "$COMMIT_COUNT" -gt 1 ]; then
            echo "::error::This PR contains $COMMIT_COUNT commits. Please squash into a single commit."
            exit 1
          fi
```

### Branch Protection

Combined with branch protection rules:
- Required status checks include commit count validation
- Squash merge is the only allowed merge strategy
- Linear history is required

---

## Developer Workflow

### Compliant Workflow Example

```bash
# Create feature branch
git checkout release
git pull origin release
git checkout -b feat/add-user-authentication

# Make changes (multiple local commits are fine during development)
git add src/auth.ts
git commit -m "wip: initial auth setup"

git add src/middleware.ts
git commit -m "wip: add middleware"

git add tests/auth.test.ts
git commit -m "wip: add tests"

# Before pushing: squash all commits into one
git rebase -i origin/release
# In the editor, change all commits except first to "squash" or "s"
# Write final commit message following semantic format

# Push and create PR
git push origin feat/add-user-authentication
gh pr create --title "feat: add user authentication" --body "..."
```

### Non-Compliant Example (Will Fail CI)

```bash
# Multiple commits pushed without squashing
git checkout -b feat/new-feature
git commit -m "add feature"
git commit -m "fix typo"
git commit -m "add tests"
git push origin feat/new-feature  # PR will fail commit count check
```

---

## Fixing Policy Violations

If your PR fails the single commit check, use one of these methods:

### Method 1: Interactive Rebase (Recommended)

```bash
# Count commits ahead of release
git rev-list --count origin/release..HEAD

# Interactive rebase to squash commits
git rebase -i origin/release

# In the editor that opens:
# - Keep the first commit as "pick"
# - Change all subsequent commits to "squash" or "s"
# Example:
#   pick abc1234 feat: main feature implementation
#   squash def5678 fix typo
#   squash ghi9012 add tests

# Save and close editor, then write your final commit message

# Force push (required after rebase)
git push --force-with-lease origin your-branch
```

### Method 2: Soft Reset

```bash
# Reset to release branch, keeping all changes staged
git reset --soft origin/release

# Create single commit with all changes
git commit -m "feat: your feature description"

# Force push
git push --force-with-lease origin your-branch
```

### Method 3: Manual Squash

```bash
# Reset to N commits back (where N is number of commits to squash)
git reset --soft HEAD~3  # Squash last 3 commits

# Commit all staged changes
git commit -m "feat: your feature description"

# Force push
git push --force-with-lease origin your-branch
```

---

## Semantic Commit Message Format

All commits must follow the [Conventional Commits](https://www.conventionalcommits.org/) specification:

```
<type>(<scope>): <description>

[optional body]

[optional footer(s)]
```

### Types

| Type | Description | Example |
|------|-------------|---------|
| `feat` | New feature | `feat(auth): add OAuth2 support` |
| `fix` | Bug fix | `fix(api): handle null response` |
| `docs` | Documentation only | `docs: update API documentation` |
| `style` | Code style (formatting) | `style: fix indentation` |
| `refactor` | Code refactoring | `refactor(core): simplify logic` |
| `perf` | Performance improvement | `perf(db): optimize queries` |
| `test` | Adding/updating tests | `test(auth): add unit tests` |
| `build` | Build system changes | `build: update dependencies` |
| `ci` | CI configuration | `ci: add GitHub Actions workflow` |
| `chore` | Maintenance tasks | `chore: clean up unused files` |
| `revert` | Revert a commit | `revert: feat(auth): add OAuth2` |

### Commit Message Examples

**Feature with scope:**
```
feat(authentication): implement JWT token refresh

- Add automatic token refresh before expiration
- Store refresh token securely in httpOnly cookie
- Add retry logic for failed refresh attempts

Closes #123
```

**Bug fix:**
```
fix(api): prevent race condition in user creation

The user creation endpoint could create duplicate users when
called simultaneously. Added database-level unique constraint
and application-level mutex.

Fixes #456
```

**Breaking change:**
```
feat(api)!: change authentication endpoint response format

BREAKING CHANGE: The /auth/login endpoint now returns
{ token, user } instead of { accessToken, userData }
```

---

## Benefits

### Clean Git History

```
* abc1234 feat(payments): add Stripe integration
* def5678 fix(auth): resolve session timeout issue
* ghi9012 feat(users): implement user profiles
* jkl3456 chore(deps): update dependencies
```

vs. cluttered history:

```
* abc1234 add stripe
* def5678 fix typo
* ghi9012 wip
* jkl3456 more changes
* mno7890 fix tests
* pqr1234 actually fix tests
```

### Better Code Review

- Reviewers see complete, coherent changes
- No need to track incremental fixes across commits
- Clear understanding of what the PR accomplishes

### Simplified Maintenance

- Easy to revert entire features: `git revert <commit>`
- Bisect works effectively for finding bugs
- Cherry-picking features between branches is straightforward
- Release notes can be auto-generated from commit messages

---

## Troubleshooting

### Common Issues

#### "error: cannot rebase: You have unstaged changes"
```bash
# Stash your changes first
git stash
git rebase -i origin/release
git stash pop
```

#### "CONFLICT during rebase"
```bash
# Resolve conflicts in affected files
git add <resolved-files>
git rebase --continue

# Or abort if needed
git rebase --abort
```

#### "rejected - non-fast-forward"
```bash
# After rebasing, you must force push
git push --force-with-lease origin your-branch
```

#### "force-with-lease rejected"
```bash
# Someone else pushed to your branch, fetch and retry
git fetch origin
git rebase origin/release
git push --force-with-lease origin your-branch
```

#### Lost commits after reset
```bash
# Find lost commits in reflog
git reflog

# Restore to a previous state
git reset --hard HEAD@{2}
```

---

## FAQ

### Q: Can I make multiple commits locally during development?

**A:** Yes! Make as many local commits as you need during development. Just squash them into a single commit before pushing or creating a PR.

### Q: What if I need to update my PR after review feedback?

**A:** Two options:
1. **Amend your commit** (recommended):
   ```bash
   git add .
   git commit --amend --no-edit
   git push --force-with-lease
   ```
2. **Add new commit then squash**:
   ```bash
   git add .
   git commit -m "address review feedback"
   git rebase -i origin/release  # squash commits
   git push --force-with-lease
   ```

### Q: Does GitHub's "Squash and merge" satisfy this policy?

**A:** Yes! If your branch protection is set to only allow squash merging, GitHub will automatically squash all commits into one when merging. However, squashing locally gives you more control over the final commit message.

### Q: What about merge commits from updating my branch?

**A:** Avoid merge commits by using rebase instead:
```bash
# Instead of: git merge origin/release
git fetch origin
git rebase origin/release
```

### Q: How do I write a good commit message for squashed commits?

**A:** Summarize the overall change, not the individual steps:
- Bad: "add feature, fix typo, add tests, fix tests"
- Good: "feat(auth): implement two-factor authentication"

### Q: What if my feature is too large for one commit?

**A:** Consider breaking it into smaller, independent PRs. Each PR should:
- Be independently deployable
- Not break existing functionality
- Have its own single, semantic commit

### Q: Can administrators bypass this policy?

**A:** With proper branch protection settings ("Do not allow bypassing"), even administrators must follow the policy. This ensures consistency across all contributors.

---

## Related Documentation

- [Conventional Commits Specification](https://www.conventionalcommits.org/)
- [Git Interactive Rebase](https://git-scm.com/docs/git-rebase#_interactive_mode)
- [GitHub Squash Merging](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-pull-request-commits)
